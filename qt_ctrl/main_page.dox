//  For emacs: -*- C -*-

/**
 ** @mainpage  ROS-Qt Control Package (<tt>qt_ctrl</tt>) Documentation
 ** @htmlinclude manifest.html
 **
 ** The ROS package <tt>qt_ctrl</tt> aims at proposing several 
 ** controllers for ROS with Qt GUI, in order to compare them.
 ** Please note that <a href="http://ros.org">ROS</a> is currently 
 ** only setup to handle <a href="http://doc.qt.io/archives/qt-4.8"
 ** >Qt 4</a>, not <a href="http://doc.qt.io/qt-5">Qt 5</a>.
 ** I am currently searching how to make it work on Ubuntu 18.04,
 ** which only includes <a href="http://doc.qt.io/qt-5">Qt 5</a> and 
 ** <a href="http://wiki.ros.org/melodic">ROS Melodic</a>, for which 
 ** several ROS packages (<tt><a href="http://wiki.ros.org/qt_build"
 ** >qt_build</a></tt> and those 
 ** for <a href="http://wiki.ros.org/turtlebot">Turtlebot</a>) are 
 ** not yet available.
 **
 ** This documentation is generated using <tt><a href=
 **  "http://wiki.ros.org/rosdoc_lite">rosdoc_lite</a></tt> and 
 ** <a href="http:doxygen.org">Doxygen</a>.
 ** It seems impossible to change the configuration of <tt><a href=
 **  "http://wiki.ros.org/rosdoc_lite">rosdoc_lite</a></tt> in order
 ** to include direct links to ROS' and Qt's online documentations.
 ** References to these documentations have thus been gathered 
 ** in a @ref refs "specific page".
 **
 ** <ul>
 ** <li> Several versions 0.1.* were developped in 2017 
 **      from B. Lesquoy's work, realised during is Master course. 
 **      They were only using ROS.
 ** </li> 
 ** <li> Version 0.2.0 was the first to use both Qt and ROS.
 **      Based on the code generated by <tt><a href=
 **      "http://wiki.ros.org/qt_create">catkin_create_qt_pkg</a></tt>,
 **      it is a basic teleoperation application, sending constant 
 **      velocities to ROS.
 ** </li> 
 ** <li> Version 0.2.1 is similar to <a href=
 ** "http://wiki.ros.org/turtlebot_teleop/Tutorials/indigo/Keyboard%20Teleop"
 **      >the Turtlebot keyboard teleoperation</a>, except that 
 **      it is based on a @ref ROSnode "C++ class" (instead of a Python 
 **      script) using a @ref QtCtrlGUI "Qt GUI".  It also includes 
 **      a complete documentation.
 ** </li> 
 ** <li> Version 0.2.2 adds display of the commands published and 
 **      of some of the odometry data recieved.
 **      It makes me discover a feature (this is not a bug) of Qt about 
 **      @ref refs_qt_gui-thread "graphical object and multi-threads".
 ** </li> 
 ** <li> Version 0.2.3 adds the possibility to save the odometry data 
 **      in a csv file (to handle it easily later, either 
 **       by a personnal program or in a spreadsheet).
 ** </li> 
 ** <li> Version 0.2.4 allows to load from a file the translation and 
 **      angular accelerations, together with the associated duration, 
 **      making it possible to transform a sequence of accelerations 
 **      with their duration into a path, i.e. a sequence of position, 
 **      extracted from the csv savefile.
 ** </li> 
 ** <li> Version 0.3.0 does not add any functionality to the programm, 
 **      but it changes the code structure: where controllers where 
 **      previously selected through conditionals, seperate classes and 
 **      inheritance are now used in order to ease future developments.
 **      Each controller now inherits an @ref Controller "abstract class", 
 **      which declares the methods used by the @ref ROSnode "ROS node".
 **      Similarly, each of its interface will inherit another abstract 
 **      class.
 ** </li> 
 ** <li> Version 0.3.1 adds a new category of controllers, which tries 
 **      to @ref TrackingCtrl "track a given trajectory".
 ** </li> 
 ** <li> Version 0.3.2 adds a new category of controllers, which tries 
 **      to @ref ReachingCtrl "reach a given oriented point".
 **      First example of reaching controller uses @ref refs_iseeml 
 **      library, from which some of the model classes (vectors, points 
 **       and oriented points) were taken.
 **      @ref refs_iseeml classes and library are now directly used.
 ** </li> 
 ** </ul>
 **/

